<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TRON Snake – 2 Player</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #07111f 0, #02030a 40%, #000000 100%);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #e0f7ff;
    }

    .game-shell {
      background: linear-gradient(145deg, rgba(0, 255, 255, 0.08), rgba(0, 123, 255, 0.08));
      border-radius: 24px;
      padding: 24px 28px 22px;
      box-shadow:
        0 0 20px rgba(0, 255, 255, 0.25),
        0 0 40px rgba(0, 180, 255, 0.45),
        0 0 90px rgba(0, 160, 255, 0.5);
      border: 1px solid rgba(0, 220, 255, 0.9);
      max-width: 720px;
      width: 96%;
      backdrop-filter: blur(10px);
    }

    .game-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .title {
      font-size: 1.4rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: #7df9ff;
      text-shadow:
        0 0 6px rgba(0, 255, 255, 0.9),
        0 0 14px rgba(0, 180, 255, 0.7);
      white-space: nowrap;
    }

    .badge {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(0, 255, 255, 0.7);
      background: rgba(0, 0, 0, 0.48);
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }

    .stats {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      gap: 10px;
      font-size: 0.9rem;
      color: #a8eaff;
      flex-wrap: wrap;
    }

    .stat-chip {
      background: rgba(0, 0, 0, 0.7);
      border-radius: 999px;
      padding: 4px 10px;
      border: 1px solid rgba(0, 200, 255, 0.8);
      box-shadow: 0 0 10px rgba(0, 200, 255, 0.45);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.8rem;
      min-width: 80px;
      justify-content: center;
    }

    .stat-chip.p1 {
      border-color: rgba(0, 255, 255, 0.9);
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
    }

    .stat-chip.p2 {
      border-color: rgba(255, 160, 0, 0.9);
      box-shadow: 0 0 10px rgba(255, 160, 0, 0.8);
    }

    .stat-label {
      text-transform: uppercase;
      opacity: 0.65;
      letter-spacing: 0.12em;
      font-size: 0.7rem;
    }

    .stat-value {
      font-weight: 600;
      color: #7df9ff;
      text-shadow: 0 0 6px rgba(0, 255, 255, 0.9);
    }

    .stat-chip.p2 .stat-value {
      color: #ffcf7a;
      text-shadow: 0 0 6px rgba(255, 200, 120, 0.9);
    }

    .controls-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 14px;
      font-size: 0.75rem;
      color: #89d8ff;
      flex-wrap: wrap;
    }

    .controls-row span {
      opacity: 0.9;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      flex-wrap: wrap;
    }

    .key {
      border-radius: 6px;
      border: 1px solid rgba(0, 220, 255, 0.7);
      padding: 2px 6px;
      margin: 0 2px;
      font-size: 0.7rem;
      background: rgba(0, 0, 0, 0.85);
      box-shadow: 0 0 12px rgba(0, 255, 255, 0.5);
    }

    .key.orange {
      border-color: rgba(255, 160, 0, 0.8);
      box-shadow: 0 0 12px rgba(255, 160, 0, 0.7);
    }

    .game-area {
      position: relative;
      border-radius: 18px;
      padding: 10px;
      background:
        radial-gradient(circle at 0 0, rgba(0, 255, 255, 0.1) 0, transparent 55%),
        radial-gradient(circle at 100% 100%, rgba(0, 120, 255, 0.16) 0, transparent 55%),
        rgba(0, 0, 0, 0.9);
      box-shadow:
        inset 0 0 12px rgba(0, 255, 255, 0.22),
        0 0 20px rgba(0, 140, 255, 0.7);
    }

    canvas {
      display: block;
      margin: 0 auto;
      background: radial-gradient(circle at top, #071019 0, #02050b 50%, #000000 100%);
      border-radius: 10px;
      border: 1px solid rgba(0, 255, 255, 0.5);
      box-shadow:
        0 0 18px rgba(0, 255, 255, 0.4),
        0 0 35px rgba(0, 150, 255, 0.6);
    }

    .game-overlay {
      pointer-events: none;
      position: absolute;
      inset: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      border-radius: 10px;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.78), rgba(0, 10, 22, 0.92));
      backdrop-filter: blur(4px);
      color: #e0faff;
      opacity: 0;
      transition: opacity 0.2s ease-out;
    }

    .game-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .overlay-title {
      font-size: 1.3rem;
      margin-bottom: 6px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: #7df9ff;
      text-shadow:
        0 0 10px rgba(0, 255, 255, 0.9),
        0 0 22px rgba(0, 160, 255, 0.7);
    }

    .overlay-subtitle {
      font-size: 0.95rem;
      margin-bottom: 14px;
      opacity: 0.9;
    }

    .overlay-score {
      font-size: 0.95rem;
      margin-bottom: 14px;
      color: #a8eaff;
    }

    .btn-row {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 6px;
    }

    button {
      border-radius: 999px;
      padding: 7px 18px;
      border: 1px solid rgba(0, 255, 255, 0.9);
      background: radial-gradient(circle at top, rgba(0, 255, 255, 0.24), rgba(0, 60, 130, 0.85));
      color: #e5fbff;
      font-size: 0.8rem;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      cursor: pointer;
      transition: transform 0.12s ease-out, box-shadow 0.12s ease-out, background 0.12s ease-out;
      box-shadow:
        0 0 10px rgba(0, 255, 255, 0.6),
        0 0 20px rgba(0, 140, 255, 0.7);
      white-space: nowrap;
    }

    button:hover {
      transform: translateY(-1px) scale(1.02);
      box-shadow:
        0 0 14px rgba(0, 255, 255, 0.8),
        0 0 32px rgba(0, 160, 255, 0.9);
    }

    button:active {
      transform: translateY(0) scale(0.98);
      box-shadow:
        0 0 8px rgba(0, 255, 255, 0.7),
        0 0 18px rgba(0, 140, 255, 0.8);
    }

    button.secondary {
      background: radial-gradient(circle at top, rgba(0, 255, 255, 0.12), rgba(0, 0, 0, 0.9));
      border-color: rgba(0, 200, 255, 0.7);
      box-shadow: 0 0 10px rgba(0, 200, 255, 0.5);
    }

    /* Mode toggle button tweaks */
    .mode-toggle-wrap {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    button.mode-toggle {
      padding: 4px 12px;
      font-size: 0.7rem;
      letter-spacing: 0.12em;
    }

    button.mode-toggle.active-mode {
      box-shadow:
        0 0 12px rgba(0, 255, 255, 0.9),
        0 0 24px rgba(0, 200, 255, 1);
      border-color: rgba(0, 255, 255, 1);
    }

    .footer-note {
      margin-top: 10px;
      font-size: 0.7rem;
      text-align: center;
      opacity: 0.7;
      letter-spacing: 0.11em;
      text-transform: uppercase;
    }

    @media (max-width: 720px) {
      .title {
        font-size: 1.1rem;
        letter-spacing: 0.16em;
      }

      canvas {
        width: 320px;
        height: 320px;
      }

      .game-shell {
        padding: 18px 18px 16px;
      }
    }
  </style>
</head>
<body>
  <div class="game-shell">
    <div class="game-header">
      <div class="title">TRON SNAKE 2P</div>
      <div class="badge">Neon Grid v2.2</div>
    </div>

    <div class="stats">
      <div class="stat-chip p1">
        <span class="stat-label">P1 Score</span>
        <span id="scoreP1" class="stat-value">0</span>
      </div>
      <div class="stat-chip p2">
        <span class="stat-label">P2 Score</span>
        <span id="scoreP2" class="stat-value">-</span>
      </div>
      <div class="stat-chip">
        <span class="stat-label">High</span>
        <span id="highScore" class="stat-value">0</span>
      </div>
      <div class="stat-chip">
        <span class="stat-label">Speed</span>
        <span id="speed" class="stat-value">1x</span>
      </div>
    </div>

    <div class="controls-row">
      <span>
        <strong>P1</strong>:
        <span class="key">↑</span><span class="key">↓</span><span class="key">←</span><span class="key">→</span>
      </span>
      <span>
        <strong>P2</strong>:
        <span class="key orange">W</span><span class="key orange">A</span><span class="key orange">S</span><span class="key orange">D</span>
      </span>
      <span>
        <span class="key">Space</span> Pause / Resume
      </span>
      <span class="mode-toggle-wrap">
        <span class="stat-label">Mode</span>
        <button id="modeBtn" class="secondary mode-toggle">1 Player</button>
      </span>
    </div>

    <div class="game-area">
      <!-- Bigger play area -->
      <canvas id="gameCanvas" width="560" height="560"></canvas>

      <div id="overlay" class="game-overlay visible">
        <div class="overlay-title">Ready?</div>
        <div class="overlay-subtitle">
          Solo run. Eat energy nodes, grow longer, and don’t hit the walls or your own trail.
        </div>
        <div class="overlay-score" id="overlayScore"></div>
        <div class="btn-row">
          <button id="startBtn">Start</button>
          <button id="resetHighBtn" class="secondary">Reset High Score</button>
        </div>
      </div>
    </div>

    <div class="footer-note">
      P1: Arrows • P2: WASD (2P mode) • Hit any snake or wall = derezzed.
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const overlay = document.getElementById('overlay');
    const overlayScore = document.getElementById('overlayScore');
    const startBtn = document.getElementById('startBtn');
    const resetHighBtn = document.getElementById('resetHighBtn');
    const modeBtn = document.getElementById('modeBtn');

    const scoreP1El = document.getElementById('scoreP1');
    const scoreP2El = document.getElementById('scoreP2');
    const highScoreEl = document.getElementById('highScore');
    const speedEl = document.getElementById('speed');

    const gridSize = 20;
    const tileCount = canvas.width / gridSize;

    let snakes;
    let food;
    let gameLoopId = null;
    let gameSpeedMs = 130; // lower = faster
    let running = false;
    let gameOver = false;
    let highScore = 0;
    let twoPlayer = false; // default: 1 Player mode

    // slow-mo state
    let slowmoActive = false;
    let slowmoTicks = 0;
    let pendingDeathIds = [];

    (function initHighScore() {
      const stored = localStorage.getItem('tronSnake2PHighScore');
      if (stored !== null && !isNaN(parseInt(stored, 10))) {
        highScore = parseInt(stored, 10);
        highScoreEl.textContent = highScore;
      }
      updateSpeedDisplay();
    })();

    function updateModeUi() {
      modeBtn.textContent = twoPlayer ? '2 Players' : '1 Player';
      if (twoPlayer) {
        modeBtn.classList.add('active-mode');
      } else {
        modeBtn.classList.remove('active-mode');
      }
      scoreP2El.textContent = twoPlayer ? '0' : '-';
    }

    function setOverlayForMode(initial = false) {
      if (initial) {
        overlay.classList.add('visible');
      }
      if (!running && !gameOver) {
        overlay.querySelector('.overlay-title').textContent = 'Ready?';
        overlay.querySelector('.overlay-subtitle').textContent = twoPlayer
          ? 'Two light cycles. One grid. Eat energy nodes, grow longer, and don’t touch any snake.'
          : 'Solo run. Eat energy nodes, grow longer, and don’t hit the walls or your own trail.';
        overlayScore.textContent = '';
        startBtn.textContent = 'Start';
      }
    }

    function createSnakes() {
      const midY = Math.floor(tileCount / 2);
      const quarterX = Math.floor(tileCount / 4);
      const threeQuarterX = tileCount - quarterX - 1;

      const snake1 = {
        id: 1,
        name: 'Player 1',
        segments: [
          { x: quarterX + 2, y: midY },
          { x: quarterX + 1, y: midY },
          { x: quarterX, y: midY }
        ],
        direction: { x: 1, y: 0 },
        nextDirection: { x: 1, y: 0 },
        alive: true,
        score: 0
      };

      const snake2 = {
        id: 2,
        name: 'Player 2',
        segments: [
          { x: threeQuarterX - 2, y: midY },
          { x: threeQuarterX - 1, y: midY },
          { x: threeQuarterX, y: midY }
        ],
        direction: { x: -1, y: 0 },
        nextDirection: { x: -1, y: 0 },
        alive: twoPlayer,        // only alive in 2P mode
        score: 0
      };

      if (!twoPlayer) {
        snake2.segments = [];   // no body in 1P mode
      }

      snakes = [snake1, snake2];
      scoreP1El.textContent = '0';
      scoreP2El.textContent = twoPlayer ? '0' : '-';
    }

    function resetGame() {
      createSnakes();
      gameSpeedMs = 130;
      gameOver = false;
      running = false;
      slowmoActive = false;
      slowmoTicks = 0;
      pendingDeathIds = [];
      spawnFood();
      updateSpeedDisplay();
    }

    function spawnFood() {
      let newFood;
      do {
        newFood = {
          x: Math.floor(Math.random() * tileCount),
          y: Math.floor(Math.random() * tileCount)
        };
      } while (snakes.some(s =>
        s.segments.some(seg => seg.x === newFood.x && seg.y === newFood.y)
      ));
      food = newFood;
    }

    function setDirectionForSnake(snakeId, dx, dy) {
      const snake = snakes.find(s => s.id === snakeId);
      if (!snake || !snake.alive) return;

      const current = snake.direction;
      // prevent 180° turns
      if ((dx === -current.x && dy === -current.y) ||
          (dx === current.x && dy === current.y)) {
        return;
      }
      snake.nextDirection = { x: dx, y: dy };
    }

    function update() {
      // If we're in slow-mo "about to crash" mode, just count down & then kill
      if (slowmoActive) {
        slowmoTicks--;
        draw();
        if (slowmoTicks <= 0) {
          slowmoActive = false;
          // actually apply the deaths now
          snakes.forEach(s => {
            if (pendingDeathIds.includes(s.id)) s.alive = false;
          });
          handleGameOver(pendingDeathIds);
        }
        return;
      }

      // Apply buffered directions
      snakes.forEach(s => {
        if (s.alive) {
          s.direction = { x: s.nextDirection.x, y: s.nextDirection.y };
        }
      });

      const moves = snakes.map(s => {
        if (!s.alive || s.segments.length === 0) return null;
        const head = s.segments[0];
        return {
          snake: s,
          newHead: { x: head.x + s.direction.x, y: head.y + s.direction.y }
        };
      });

      const deathsThisTick = new Set();

      // Wall + body collision (with any snake, including self)
      moves.forEach(move => {
        if (!move) return;
        const { snake, newHead } = move;
        if (
          newHead.x < 0 ||
          newHead.x >= tileCount ||
          newHead.y < 0 ||
          newHead.y >= tileCount
        ) {
          deathsThisTick.add(snake.id);
          return;
        }

        // collide with any existing segment (before movement)
        const hitSnake = snakes.some(s =>
          s.segments.some(seg => seg.x === newHead.x && seg.y === newHead.y)
        );
        if (hitSnake) {
          deathsThisTick.add(snake.id);
        }
      });

      // Head-on collisions (two heads move into the same tile)
      for (let i = 0; i < moves.length; i++) {
        const mi = moves[i];
        if (!mi) continue;
        for (let j = i + 1; j < moves.length; j++) {
          const mj = moves[j];
          if (!mj) continue;
          if (mi.newHead.x === mj.newHead.x && mi.newHead.y === mj.newHead.y) {
            deathsThisTick.add(mi.snake.id);
            deathsThisTick.add(mj.snake.id);
          }
        }
      }

      // If there is a crash coming, enter slow-mo instead of killing immediately
      if (deathsThisTick.size > 0) {
        pendingDeathIds = Array.from(deathsThisTick);
        slowmoActive = true;
        slowmoTicks = 6; // how many slow-mo frames
        gameSpeedMs = 260; // slower ticks during slow-mo
        updateGameLoop();
        draw();
        return;
      }

      // Move snakes & handle food
      let foodEatenThisTick = false;

      moves.forEach(move => {
        if (!move) return;
        const { snake, newHead } = move;
        snake.segments.unshift(newHead);

        if (newHead.x === food.x && newHead.y === food.y) {
          snake.score += 10;
          if (snake.id === 1) {
            scoreP1El.textContent = snake.score;
          } else {
            scoreP2El.textContent = snake.score;
          }

          const bestNow = Math.max(snakes[0].score, snakes[1].score);
          if (bestNow > highScore) {
            highScore = bestNow;
            highScoreEl.textContent = highScore;
            localStorage.setItem('tronSnake2PHighScore', String(highScore));
          }

          foodEatenThisTick = true;

          // speed up slightly as total score climbs
          const totalScore = snakes[0].score + snakes[1].score;
          if (totalScore % 40 === 0 && gameSpeedMs > 70) {
            gameSpeedMs -= 5;
            updateGameLoop();
            updateSpeedDisplay();
          }
        } else {
          // no food: move by removing tail
          snake.segments.pop();
        }
      });

      if (foodEatenThisTick) {
        spawnFood();
      }

      draw();
    }

    function drawBackground() {
      const gradient = ctx.createRadialGradient(
        canvas.width / 2,
        0,
        40,
        canvas.width / 2,
        canvas.height / 2,
        canvas.width
      );
      gradient.addColorStop(0, '#071019');
      gradient.addColorStop(0.4, '#020712');
      gradient.addColorStop(1, '#000000');

      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawGrid();
    }

    function drawGrid() {
      ctx.save();
      ctx.strokeStyle = 'rgba(0, 255, 255, 0.08)';
      ctx.lineWidth = 1;

      for (let i = 0; i <= tileCount; i++) {
        const pos = i * gridSize;
        ctx.beginPath();
        ctx.moveTo(pos + 0.5, 0);
        ctx.lineTo(pos + 0.5, canvas.height);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, pos + 0.5);
        ctx.lineTo(canvas.width, pos + 0.5);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawSnakes() {
      snakes.forEach(snake => {
        if (!snake.alive || snake.segments.length === 0) return;

        const mainColor = snake.id === 1 ? '0,255,255' : '255,160,0';
        const secondaryColor = snake.id === 1 ? '0,140,255' : '255,80,0';

        for (let i = snake.segments.length - 1; i >= 0; i--) {
          const seg = snake.segments[i];
          const x = seg.x * gridSize;
          const y = seg.y * gridSize;

          const isHead = i === 0;
          const intensity = isHead ? 1 : (0.4 + (i / snake.segments.length) * 0.4);

          const gradient = ctx.createLinearGradient(
            x,
            y,
            x + gridSize,
            y + gridSize
          );
          gradient.addColorStop(0, `rgba(${mainColor}, ${0.4 + intensity * 0.3})`);
          gradient.addColorStop(1, `rgba(${secondaryColor}, ${0.7 + intensity * 0.2})`);

          ctx.save();
          ctx.fillStyle = gradient;
          ctx.shadowColor = `rgba(${mainColor}, 0.95)`;
          ctx.shadowBlur = isHead ? 22 : 12;

          const inset = isHead ? 2 : 3;
          ctx.fillRect(
            x + inset,
            y + inset,
            gridSize - inset * 2,
            gridSize - inset * 2
          );

          if (isHead) {
            // visor
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            const visorWidth = gridSize * 0.6;
            const visorHeight = gridSize * 0.28;
            const vx = x + (gridSize - visorWidth) / 2;
            const vy = y + (gridSize - visorHeight) / 2;
            ctx.fillRect(vx, vy, visorWidth, visorHeight);

            ctx.fillStyle = snake.id === 1
              ? 'rgba(0, 255, 255, 0.9)'
              : 'rgba(255, 200, 120, 0.9)';
            ctx.fillRect(vx + 1.5, vy + 1.5, visorWidth / 3.5, visorHeight - 3);
          }
          ctx.restore();
        }
      });
    }

    function drawFood() {
      const x = food.x * gridSize;
      const y = food.y * gridSize;

      ctx.save();
      ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
      ctx.shadowBlur = 18;

      const gradient = ctx.createRadialGradient(
        x + gridSize / 2,
        y + gridSize / 2,
        2,
        x + gridSize / 2,
        y + gridSize / 2,
        gridSize / 2
      );
      gradient.addColorStop(0, 'rgba(0, 255, 255, 1)');
      gradient.addColorStop(0.5, 'rgba(0, 180, 255, 0.85)');
      gradient.addColorStop(1, 'rgba(0, 40, 80, 0.2)');

      ctx.fillStyle = gradient;
      const radius = gridSize * 0.4;
      ctx.beginPath();
      ctx.arc(
        x + gridSize / 2,
        y + gridSize / 2,
        radius,
        0,
        Math.PI * 2
      );
      ctx.fill();

      ctx.restore();
    }

    function drawSlowmoOverlay() {
      ctx.save();
      ctx.fillStyle = 'rgba(255, 255, 255, 0.03)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.lineWidth = 4;
      ctx.strokeRect(4, 4, canvas.width - 8, canvas.height - 8);
      ctx.restore();
    }

    function draw() {
      drawBackground();
      drawFood();
      drawSnakes();
      if (slowmoActive) {
        drawSlowmoOverlay();
      }
    }

    function handleGameOver(deadIds) {
      running = false;
      gameOver = true;
      clearInterval(gameLoopId);
      gameLoopId = null;

      const p1Dead = deadIds.includes(1);
      const p2Dead = deadIds.includes(2);

      overlay.classList.add('visible');

      if (!twoPlayer) {
        // Single-player messages
        overlay.querySelector('.overlay-title').textContent = 'Derezzed!';
        overlay.querySelector('.overlay-subtitle').textContent =
          'You hit a wall or your own trail. Try again and chase a higher score.';
      } else {
        // Two-player messages
        if (p1Dead && p2Dead) {
          overlay.querySelector('.overlay-title').textContent = 'Both Derezzed!';
          overlay.querySelector('.overlay-subtitle').textContent =
            'Head-on collision or mutual destruction. The Grid claims you both.';
        } else if (p1Dead) {
          overlay.querySelector('.overlay-title').textContent = 'P1 Derezzed';
          overlay.querySelector('.overlay-subtitle').textContent =
            'Player 1 hit a snake or the wall. Player 2 survives… for now.';
        } else if (p2Dead) {
          overlay.querySelector('.overlay-title').textContent = 'P2 Derezzed';
          overlay.querySelector('.overlay-subtitle').textContent =
            'Player 2 hit a snake or the wall. Player 1 survives… for now.';
        }
      }

      overlayScore.textContent = twoPlayer
        ? `P1: ${snakes[0].score}  •  P2: ${snakes[1].score}  •  Best: ${highScore}`
        : `P1: ${snakes[0].score}  •  Best: ${highScore}`;
      startBtn.textContent = 'Play Again';
    }

    function startGame() {
      resetGame();
      overlay.classList.remove('visible');
      running = true;
      updateGameLoop();
      draw();
    }

    function pauseGame() {
      if (!running || gameOver) return;
      running = false;
      clearInterval(gameLoopId);
      gameLoopId = null;

      overlay.classList.add('visible');
      overlay.querySelector('.overlay-title').textContent = 'Paused';
      overlay.querySelector('.overlay-subtitle').textContent =
        'Take a breather in the Grid. Press Space or Resume to continue.';
      overlayScore.textContent = twoPlayer
        ? `P1: ${snakes[0].score}  •  P2: ${snakes[1].score}  •  Best: ${highScore}`
        : `P1: ${snakes[0].score}  •  Best: ${highScore}`;
      startBtn.textContent = 'Resume';
    }

    function resumeGame() {
      if (running || gameOver) return;
      overlay.classList.remove('visible');
      running = true;
      updateGameLoop();
    }

    function updateGameLoop() {
      if (gameLoopId) clearInterval(gameLoopId);
      gameLoopId = setInterval(update, gameSpeedMs);
    }

    function updateSpeedDisplay() {
      const base = 130;
      const factor = (base / gameSpeedMs).toFixed(1);
      speedEl.textContent = factor + 'x';
    }

    // Input handling
    document.addEventListener('keydown', (e) => {
      // prevent page scroll when using arrows / space for the game
      if (
        e.code === 'Space' ||
        e.key === 'ArrowUp' ||
        e.key === 'ArrowDown' ||
        e.key === 'ArrowLeft' ||
        e.key === 'ArrowRight'
      ) {
        e.preventDefault();
      }

      if (e.code === 'Space') {
        if (!running && !gameOver) {
          resumeGame();
        } else if (running && !gameOver) {
          pauseGame();
        } else if (gameOver) {
          startGame();
        }
        return;
      }

      switch (e.key) {
        // P1 – Arrows
        case 'ArrowUp':
          setDirectionForSnake(1, 0, -1);
          break;
        case 'ArrowDown':
          setDirectionForSnake(1, 0, 1);
          break;
        case 'ArrowLeft':
          setDirectionForSnake(1, -1, 0);
          break;
        case 'ArrowRight':
          setDirectionForSnake(1, 1, 0);
          break;

        // P2 – WASD
        case 'w':
        case 'W':
          setDirectionForSnake(2, 0, -1);
          break;
        case 's':
        case 'S':
          setDirectionForSnake(2, 0, 1);
          break;
        case 'a':
        case 'A':
          setDirectionForSnake(2, -1, 0);
          break;
        case 'd':
        case 'D':
          setDirectionForSnake(2, 1, 0);
          break;
      }
    });

    startBtn.addEventListener('click', () => {
      if (gameOver) {
        startGame();
      } else if (!running) {
        resumeGame();
      }
    });

    resetHighBtn.addEventListener('click', () => {
      highScore = 0;
      highScoreEl.textContent = '0';
      localStorage.removeItem('tronSnake2PHighScore');
      overlayScore.textContent = '';
    });

    modeBtn.addEventListener('click', () => {
      // toggle between 1P / 2P
      twoPlayer = !twoPlayer;
      updateModeUi();
      resetGame();
      setOverlayForMode();
      overlay.classList.add('visible');
    });

    // Initial setup
    resetGame();
    updateModeUi();
    setOverlayForMode(true);
    draw();
  </script>
</body>
</html>